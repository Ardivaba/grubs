@namespace Grubs.UI.Inventory

@using Grubs.Equipment
@using Grubs.Equipment.Weapons
@using Grubs.Pawn
@using Grubs.UI.Components
@using Sandbox;
@using Sandbox.UI

@inherits Panel

@attribute [StyleSheet]

@if (Inventory is null)
{
    return;
}

<root>
    @for (var i = 0; i < _rows; i++)
    {
        <div class="inv-row">
            @for (var j = 0; j < _columns; j++)
            {
                <InventoryItem Equipment=@Inventory.Equipment.ElementAtOrDefault(i * _columns + j)/>
            }
        </div>
    }
</root>

@code
{
    public PlayerInventory Inventory { get; set; }

    private Equipment Current => Inventory.Equipment.ElementAtOrDefault(Inventory.ActiveSlot);
    private Weapon CurrentWeapon => Current?.Components.Get<Weapon>();

    private const int _columns = 5;
    private int _rows => (int)Math.Ceiling((float)_totalItems / _columns);
    private int _totalItems => Inventory.Equipment.Count();

    private int _currentGamepadIndex = 0;
    private bool _usedJoystick;

    public override void Tick()
    {
        SetClass("hide", !Inventory.InventoryOpen);
        Cursor.Enabled("inv", Inventory.InventoryOpen);

        if (!Input.UsingController) return;

        if (Inventory.InventoryOpen && Math.Round(Input.AnalogMove.Length) != 0 && !_usedJoystick)
        {
            _usedJoystick = true;
            PlayerInventory.Local.EquipItem(Inventory.Equipment.ElementAtOrDefault(SelectNextItemGamepadInput()));
        }

        if (Inventory.InventoryOpen && Math.Round(Input.AnalogMove.Length) == 0 && _usedJoystick)
        {
            _usedJoystick = false;
        }
    }

    protected override int BuildHash()
    {
        return HashCode.Combine(Inventory.EquipmentActive, Inventory.ActiveSlot);
    }

    private int SelectNextItemGamepadInput()
    {
        var analogX = Input.AnalogMove.x;
        var analogY = -Input.AnalogMove.y;

        var currentRow = _currentGamepadIndex / _columns;
        var currentColumn = _currentGamepadIndex % _columns;

        currentRow = analogX switch
        {
            > 0 => (currentRow - 1 + _rows) % _rows,
            < 0 => (currentRow + 1) % _rows,
            _ => currentRow
        };

        switch (analogY)
        {
            case < 0:
                currentColumn = (currentColumn - 1 + _columns) % _columns;
                break;
            case > 0:
                currentColumn = (currentColumn + 1) % _columns;
                break;
        }

        _currentGamepadIndex = currentRow * _columns + currentColumn;

        return _currentGamepadIndex;
    }
}