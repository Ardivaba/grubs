@namespace Grubs.UI.Inventory

@using Grubs.Equipment
@using Grubs.Equipment.Weapons
@using Grubs.Pawn
@using Grubs.UI.Components
@using Sandbox;
@using Sandbox.UI

@inherits Panel

@attribute [StyleSheet]

@if (Inventory is null)
{
    return;
}

<root>
    @for (var i = 0; i < 6; i++)
    {
        <div class="inv-row">
            @for (var j = 0; j < 4; j++)
            {
                <InventoryItem Equipment=@Inventory.Equipment.ElementAtOrDefault(i * 4 + j)/>
            }
        </div>
    }
</root>

@code
{
	public PlayerInventory Inventory { get; set; }

	private Equipment Current => Inventory.Equipment.ElementAtOrDefault(Inventory.ActiveSlot);
	private Equipment Next => Inventory.Equipment.ElementAtOrDefault(Inventory.GetNextSlot());
	private Equipment Prev => Inventory.Equipment.ElementAtOrDefault(Inventory.GetPrevSlot());
	private Weapon CurrentWeapon => Current?.Components.Get<Weapon>();
	private Weapon NextWeapon => Next?.Components.Get<Weapon>();
	private Weapon PrevWeapon => Prev?.Components.Get<Weapon>();

	public override void Tick()
	{
		SetClass("hide", !Inventory.InventoryOpen);
		Cursor.Enabled("inv", Inventory.InventoryOpen);

		if (!Input.UsingController) return;

		if (Inventory.InventoryOpen && Math.Round(Input.AnalogMove.Length) != 0 && !usedJoystick)
		{
			usedJoystick = true;
			PlayerInventory.Local.EquipItem(Inventory.Equipment.ElementAtOrDefault(SelectNextItemGamepadInput()));
		}

		if (Inventory.InventoryOpen && Math.Round(Input.AnalogMove.Length) == 0 && usedJoystick)
		{
			usedJoystick = false;
		}
	}

	protected override int BuildHash()
	{
		var cd = CurrentWeapon?.TimeSinceLastUsed + PrevWeapon?.TimeSinceLastUsed + NextWeapon?.TimeSinceLastUsed;
		return HashCode.Combine(Inventory.EquipmentActive, Inventory.ActiveSlot, cd);
	}

	private int currentGamepadIndex = 0;
	private bool usedJoystick;

	int SelectNextItemGamepadInput()
	{
		const int columns = 4;
		const int rows = 6;
		const int totalItems = columns * rows;

		float analogX = Input.AnalogMove.x;
		float analogY = -Input.AnalogMove.y;

		int currentRow = currentGamepadIndex / columns;
		int currentColumn = currentGamepadIndex % columns;

		if (analogX > 0)
		{
			currentRow = (currentRow - 1 + rows) % rows;
		}
		else if (analogX < 0)
		{
			currentRow = (currentRow + 1) % rows;
		}

		if (analogY < 0)
		{
			currentColumn = (currentColumn - 1 + columns) % columns;
		}
		else if (analogY > 0)
		{
			currentColumn = (currentColumn + 1) % columns;
		}
		currentGamepadIndex = currentRow * columns + currentColumn;

		return currentGamepadIndex;
	}
}